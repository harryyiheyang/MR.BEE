MRBEE_Mixture_UV=function(by,bX,byse,bXse,Rxy,LD=LD,main.cluster.thres=0.4,cluster.index=cluster.index,reliability.thres=0.8,sampling.time=100,min.cluster.size=5,robust.se=T,ebic.theta=1){
########################### Basic information #######################
sink(tempfile())
by=by/byse
byseinv=1/byse
bX=bX*byseinv
bXse=bXse*byseinv
byse1=byse
byse=byse/byse
m=length(bX)
LD=Matrix(LD,sparse=T)
Theta=solve(LD)
TC=chol(Theta)
by=as.vector(TC%*%by)
bX=as.vector(TC%*%bX)
tilde.R=as.matrix(TC%*%LD)
r=reliability.adj.uv(bX,bXse,Theta=Theta,thres=reliability.thres)
r=c(r,1)
Rxy=t(t(Rxy)*r)*r
RxyList=IVweight(byse,bXse,Rxy)
Rxyall=biasterm(RxyList=RxyList,c(1:m))
p=1
############################ Initial Estimate #######################
fit.init=fit.mixture=regmixEM(y=by,x=bX,k=2,addintercept=T)
max.cluster=ifelse(sum(fit.init$posterior[,1]>main.cluster.thres)>(m/2),1,2)
cluster.ini.1=which(fit.init$posterior[,max.cluster]>main.cluster.thres)
cluster.ini.2=setdiff(1:m,cluster.ini.1)
########################### Check if applied mixture model #######################
if(length(cluster.ini.2)>=min.cluster.size){
theta1=fit.init$beta[2,max.cluster]
theta2=fit.init$beta[2,setdiff(1:2,max.cluster)]
error=1
iter=1
cluster.1=cluster.ini.1
cluster.2=cluster.ini.2
cluster.ratio=c(length(cluster.1),length(cluster.2))/m
Rxysum1=biasterm(RxyList=RxyList,cluster.1)
Rxysum2=biasterm(RxyList=RxyList,cluster.2)
XtX1=sum(bX[cluster.1]^2)
XtX2=sum(bX[cluster.2]^2)
Xty1=sum(bX[cluster.1]*by[cluster.1])
Xty2=sum(bX[cluster.2]*by[cluster.2])
theta1=(Xty1-Rxysum1[1:p,p+1])/(XtX1-Rxysum1[1:p,1:p])
theta2=(Xty2-Rxysum1[1:p,p+1])/(XtX2-Rxysum2[1:p,1:p])
res1=by[cluster.1]-bX[cluster.1]*theta1
res2=by[cluster.2]-bX[cluster.2]*theta2
rss1=sum(res1^2)/(length(cluster.1)-2)
rss2=sum(res2^2)/(length(cluster.2)-2)
Bic=log(rss1)*length(cluster.1)+log(rss2)*length(cluster.2)+2*p*(log(2*p)*ebic.theta+log(m))
Bic=Bic/m
############################### inference #########################
names(theta1)=names(theta2)=colnames(bX)
ThetaList1=ThetaList2=c(1:sampling.time)
for(j in 1:sampling.time){
cluster.sampling <- sample(1:max(cluster.index), 0.5*max(cluster.index), replace = F)
indj=which(cluster.index%in%cluster.sampling)
indj=sort(indj)
LDj=LD[indj,indj]
Thetaj <- solve(LDj)
TCj=chol(Thetaj)
tilde.Rj=as.matrix(chol(Thetaj)%*%LDj)
byj=by[indj]
bXj=bX[indj]
theta1j=theta1
theta2j=theta2
fit.mixturej=regmixEM(y=byj,x=bXj,k=2,addintercept=T,maxit=100,epsilon=1e-4)
max.cluster=ifelse(sum(fit.mixturej$posterior[,1]>main.cluster.thres)>(length(indj)/2),1,2)
cluster.1j=which(fit.mixturej$posterior[,max.cluster]>main.cluster.thres)
cluster.2j=which(fit.mixturej$posterior[,max.cluster]<main.cluster.thres)
Rxysum1j=biasterm(RxyList=RxyList,indj[cluster.1j])
Rxysum2j=biasterm(RxyList=RxyList,indj[cluster.2j])
XtX1j=sum(bXj[cluster.1j]^2)
XtX2j=sum(bXj[cluster.2j]^2)
Xty1j=sum(bXj[cluster.1j]*byj[cluster.1j])
Xty2j=sum(bXj[cluster.2j]*byj[cluster.2j])
theta1j=(Xty1j-Rxysum1j[1:p,p+1])/(XtX1j-Rxysum1j[1:p,1:p])
theta2j=(Xty2j-Rxysum2j[1:p,p+1])/(XtX2j-Rxysum2j[1:p,1:p])
ThetaVecj=c(theta1j,theta2j)
ThetaNormj=abs(ThetaVecj-c(theta1,theta1))
theta1j=ThetaVecj[which.min(ThetaNormj)]
theta2j=ThetaVecj[which.max(ThetaNormj)]
ThetaList1[j] <- theta1j
ThetaList2[j] <- theta2j
}
indtheta1=which(theta1!=0)
indtheta2=which(theta2!=0)
theta.se1=sd(ThetaList1)
theta.cov1=var(ThetaList1)
theta.se2=sd(ThetaList2)
theta.cov2=var(ThetaList2)
if(robust.se==T){
theta.se1=mad(ThetaList1)
theta.cov1=mad(ThetaList1)^2
theta.se2=mad(ThetaList2)
theta.cov2=mad(ThetaList2)^2
}
names(theta.cov2)=names(theta.se2)=names(bX)
names(theta.cov1)=names(theta.se1)=names(bX)
A=list()
A$theta1=theta1
A$theta2=theta2
A$theta.se1=theta.se1
A$theta.cov1=theta.cov1
A$theta.se2=theta.se2
A$theta.cov2=theta.cov2
A$reliability.adjust=r
A$thetalist2=ThetaList2
A$thetalist2=ThetaList1
A$cluster1=cluster.1
A$cluster2=cluster.2
A$fit.mixture=fit.mixture
A$theta.pratt1=getPratt.uv(bX=bX[cluster.1],by=by[cluster.1],bXse=bXse[cluster.1],byse=byse[cluster.1],theta=theta1,Rxy=Rxy)
A$theta.pratt2=getPratt.uv(bX=bX[cluster.2],by=by[cluster.2],bXse=bXse[cluster.2],byse=byse[cluster.2],theta=theta2,Rxy=Rxy)
A$IsIPOD=F
A$Bic=Bic
sink()
sink()
}else{
A=list()
A$IsIPOD=T
sink()
sink()
}
return(A)
}
